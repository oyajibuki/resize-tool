<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>resize.tool</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=IBM+Plex+Sans+JP:wght@400;500;600&display=swap');

    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg: #f5f4f0;
      --surface: #fff;
      --border: #e0ddd6;
      --border-s: #b8b4ac;
      --text: #1a1916;
      --muted: #7a7872;
      --al: #f0ede6;
      --green: #2d7a4f;
      --green-bg: #e8f5ee;
      --red: #c0392b;
      --red-bg: #fde8e8;
      --violet: #6c63ff;
      --violet-bg: #f0eeff;
      --orange: #c85a0a;
      --orange-bg: #fff3e8;
      --ybg: #fff8e0;
      --ytxt: #7a5c00;
      --mono: 'IBM Plex Mono', monospace;
      --sans: 'IBM Plex Sans JP', sans-serif;
    }

    body {
      font-family: var(--sans);
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 24px 16px 64px;
    }

    header {
      max-width: 920px;
      margin: 0 auto 28px;
      display: flex;
      align-items: baseline;
      gap: 12px;
      border-bottom: 2px solid var(--text);
      padding-bottom: 12px;
    }

    header h1 {
      font-family: var(--mono);
      font-size: 20px;
      font-weight: 600;
    }

    header span {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
    }

    .wrap {
      max-width: 920px;
      margin: 0 auto;
      display: grid;
      gap: 18px;
    }

    .card {
      background: var(--surface);
      border: 1.5px solid var(--border);
      border-radius: 8px;
      padding: 20px;
    }

    .slabel {
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 600;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 12px;
    }

    /* Drop */
    .dz {
      border: 2px dashed var(--border-s);
      border-radius: 6px;
      background: var(--al);
      padding: 42px 24px;
      text-align: center;
      cursor: pointer;
      transition: all .15s;
      position: relative;
    }

    .dz:hover,
    .dz.over {
      border-color: var(--text);
      background: #ebe8e0;
    }

    .dz input[type=file] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
      width: 100%;
      height: 100%;
    }

    .dz-icon {
      font-size: 32px;
      margin-bottom: 10px;
    }

    .dz-text {
      font-family: var(--mono);
      font-size: 14px;
      color: var(--muted);
    }

    .dz-text strong {
      color: var(--text);
    }

    .dz-sub {
      font-size: 11px;
      color: var(--muted);
      margin-top: 8px;
      font-family: var(--mono);
    }

    .tag {
      display: inline-block;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 3px;
      padding: 2px 6px;
      margin: 2px;
      font-size: 11px;
    }

    /* Notice */
    .notice {
      border-radius: 6px;
      padding: 10px 14px;
      font-family: var(--mono);
      font-size: 12px;
      margin-top: 10px;
      display: none;
    }

    .notice.show {
      display: block;
    }

    .notice.plain {
      background: var(--al);
      border: 1.5px solid var(--border-s);
      color: var(--text);
    }

    .notice.orange {
      background: var(--orange-bg);
      border: 1.5px solid #e8a060;
      color: var(--orange);
    }

    .notice.yellow {
      background: var(--ybg);
      border: 1.5px solid #ffe08a;
      color: var(--ytxt);
    }

    .notice.green {
      background: var(--green-bg);
      border: 1.5px solid #8bc9a0;
      color: var(--green);
    }

    .notice.red {
      background: var(--red-bg);
      border: 1.5px solid #f0a0a0;
      color: var(--red);
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .tab {
      font-family: var(--mono);
      font-size: 12px;
      padding: 5px 12px;
      border: 1.5px solid var(--border);
      border-radius: 4px;
      background: var(--surface);
      cursor: pointer;
      transition: all .1s;
      color: var(--muted);
    }

    .tab:hover {
      border-color: var(--text);
      color: var(--text);
    }

    .tab.active {
      background: var(--text);
      color: #fff;
      border-color: var(--text);
    }

    /* Presets */
    .pgrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(148px, 1fr));
      gap: 8px;
    }

    .pc {
      border: 1.5px solid var(--border);
      border-radius: 6px;
      padding: 10px;
      cursor: pointer;
      background: var(--surface);
      transition: all .1s;
    }

    .pc:hover {
      border-color: var(--text);
    }

    .pc.sel {
      border-color: var(--text);
      background: var(--al);
    }

    .pc.vid {
      border-left: 3px solid var(--violet);
    }

    .pc.vid.sel {
      background: var(--violet-bg);
    }

    .pp {
      font-family: var(--mono);
      font-size: 10px;
      color: var(--muted);
    }

    .pn {
      font-family: var(--mono);
      font-size: 13px;
      font-weight: 600;
      margin: 2px 0;
    }

    .ps {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
    }

    .pb {
      font-size: 10px;
      font-family: var(--mono);
      margin-top: 4px;
      display: inline-block;
      padding: 1px 5px;
      border-radius: 3px;
      background: var(--border);
      color: var(--muted);
    }

    .pb.v {
      background: var(--violet-bg);
      color: var(--violet);
    }

    /* Options */
    .opts {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      margin-bottom: 14px;
    }

    .og {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .ol {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
    }

    .cr {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .xl {
      font-family: var(--mono);
      font-size: 13px;
      color: var(--muted);
    }

    input[type=number] {
      font-family: var(--mono);
      font-size: 14px;
      width: 86px;
      border: 1.5px solid var(--border);
      border-radius: 4px;
      padding: 7px 9px;
      background: var(--surface);
      color: var(--text);
    }

    input[type=number]:focus {
      outline: none;
      border-color: var(--text);
    }

    select {
      font-family: var(--mono);
      font-size: 13px;
      padding: 7px 10px;
      border: 1.5px solid var(--border);
      border-radius: 4px;
      background: var(--surface);
      color: var(--text);
      cursor: pointer;
    }

    select:focus {
      outline: none;
      border-color: var(--text);
    }

    input[type=color] {
      border: 1.5px solid var(--border);
      border-radius: 3px;
      width: 32px;
      height: 28px;
      cursor: pointer;
      padding: 2px;
    }

    .chk {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: var(--mono);
      font-size: 13px;
      cursor: pointer;
      user-select: none;
    }

    .chk input {
      accent-color: var(--text);
      width: 15px;
      height: 15px;
    }

    /* Video fmt */
    .vfmt {
      display: flex;
      gap: 6px;
      margin-bottom: 14px;
      flex-wrap: wrap;
      align-items: center;
    }

    .vb {
      font-family: var(--mono);
      font-size: 12px;
      font-weight: 600;
      padding: 6px 14px;
      border: 1.5px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      background: var(--surface);
      color: var(--muted);
      transition: all .1s;
    }

    .vb:hover:not(:disabled) {
      border-color: var(--text);
      color: var(--text);
    }

    .vb.active {
      background: var(--text);
      color: #fff;
      border-color: var(--text);
    }

    .vb:disabled {
      opacity: .35;
      cursor: not-allowed;
    }

    /* Preview */
    .prevgrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 14px;
    }

    @media (max-width:540px) {
      .prevgrid {
        grid-template-columns: 1fr;
      }
    }

    .pbox {
      border: 1.5px solid var(--border);
      border-radius: 6px;
      background: var(--surface);
      padding: 12px;
    }

    .pbox-lbl {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .pbox canvas,
    .pbox video {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 3px;
      background: #e8e6e0;
      max-height: 260px;
      object-fit: contain;
    }

    .pinfo {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      margin-top: 7px;
      line-height: 1.6;
      white-space: pre-wrap;
    }

    /* Status */
    .sbar {
      font-family: var(--mono);
      font-size: 12px;
      padding: 8px 12px;
      border-radius: 4px;
      margin-bottom: 12px;
      display: none;
    }

    .sbar.show {
      display: block;
    }

    .sbar.proc {
      background: var(--ybg);
      color: var(--ytxt);
    }

    .sbar.done {
      background: var(--green-bg);
      color: var(--green);
    }

    .sbar.err {
      background: var(--red-bg);
      color: var(--red);
    }

    .pgwrap {
      display: none;
      margin-bottom: 12px;
    }

    .pgwrap.show {
      display: block;
    }

    .pglbl {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 5px;
    }

    progress {
      width: 100%;
      height: 6px;
      border: none;
      border-radius: 3px;
      accent-color: var(--text);
    }

    /* Buttons */
    .brow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .btn-p {
      font-family: var(--mono);
      font-size: 14px;
      font-weight: 600;
      padding: 11px 22px;
      background: var(--text);
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: opacity .1s;
    }

    .btn-p:hover {
      opacity: .85;
    }

    .btn-p:disabled {
      opacity: .3;
      cursor: not-allowed;
    }

    .btn-s {
      font-family: var(--mono);
      font-size: 13px;
      padding: 11px 16px;
      background: var(--surface);
      color: var(--text);
      border: 1.5px solid var(--border-s);
      border-radius: 6px;
      cursor: pointer;
    }

    .btn-s:hover {
      border-color: var(--text);
    }

    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 12px 0;
    }

    /* Editor */
    .editor-section {
      display: none;
      margin-top: 14px;
      border-top: 1px solid var(--border);
      padding-top: 14px;
    }

    .editor-section.show {
      display: block;
    }

    .editor-label {
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 600;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 10px;
    }

    .editor-toolbar {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .editor-toolbar .zoom-display {
      font-family: var(--mono);
      font-size: 13px;
      font-weight: 600;
      color: var(--text);
      min-width: 60px;
    }

    .editor-toolbar .btn-tool {
      font-family: var(--mono);
      font-size: 12px;
      padding: 5px 10px;
      border: 1.5px solid var(--border);
      border-radius: 4px;
      background: var(--surface);
      color: var(--muted);
      cursor: pointer;
      transition: all .1s;
    }

    .editor-toolbar .btn-tool:hover {
      border-color: var(--text);
      color: var(--text);
    }

    .editor-hint {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      margin-left: auto;
    }

    .editor-canvas-wrap {
      border: 1.5px solid var(--border);
      border-radius: 6px;
      overflow: hidden;
      position: relative;
      background:
        repeating-conic-gradient(#e0ddd6 0% 25%, #fff 0% 50%) 0 0 / 16px 16px;
    }

    .editor-canvas-wrap canvas {
      display: block;
      width: 100%;
      height: auto;
      max-height: 400px;
      object-fit: contain;
      cursor: grab;
    }

    .editor-canvas-wrap canvas.dragging {
      cursor: grabbing;
    }
  </style>
</head>

<body>

  <header>
    <h1>resize.tool</h1>
    <span>ç”»åƒãƒ»å‹•ç”»ãƒªã‚µã‚¤ã‚¶ãƒ¼ â€” ãƒ–ãƒ©ã‚¦ã‚¶å®Œçµ / ã‚µãƒ¼ãƒãƒ¼ä¸è¦</span>
  </header>

  <div class="wrap">

    <!-- 01 -->
    <div class="card">
      <div class="slabel">01 â€” ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</div>
      <div class="dz" id="dz">
        <input type="file" id="fi" accept="image/*,.heic,.heif,video/*">
        <div class="dz-icon">ğŸ“</div>
        <div class="dz-text"><strong>ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°</strong>ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</div>
        <div class="dz-sub">
          <span class="tag">PNG</span><span class="tag">JPG</span><span class="tag">WebP</span><span
            class="tag">GIF</span>
          <span class="tag">HEIC</span><span class="tag">HEIF</span>
          <span class="tag">MP4</span><span class="tag">MOV</span><span class="tag">WebM</span>
        </div>
      </div>
      <div class="notice plain" id="heicNotice">HEIC / HEIF ç”»åƒã‚’æ¤œå‡ºã—ã¾ã—ãŸ â€” JPG ã¾ãŸã¯ PNG ã«å¤‰æ›ã—ã¾ã™</div>
      <div class="notice red" id="errNotice"></div>
    </div>

    <!-- 02 ãƒ—ãƒªã‚»ãƒƒãƒˆ -->
    <div class="card" id="secPreset" style="display:none">
      <div class="slabel">02 â€” ç”¨é€”ã‚’é¸æŠï¼ˆä»»æ„ï¼‰</div>
      <div class="tabs" id="platTabs">
        <button class="tab active" data-p="all">ã™ã¹ã¦</button>
        <button class="tab" data-p="lineworks">LINE WORKS</button>
        <button class="tab" data-p="line">LINE</button>
        <button class="tab" data-p="booth">BOOTH</button>
        <button class="tab" data-p="note">note</button>
        <button class="tab" data-p="youtube">YouTube</button>
        <button class="tab" data-p="tiktok">TikTok</button>
        <button class="tab" data-p="twitter">Twitter/X</button>
        <button class="tab" data-p="instagram">Instagram</button>
        <button class="tab" data-p="facebook">Facebook</button>
        <button class="tab" data-p="pinterest">Pinterest</button>
      </div>
      <div class="pgrid" id="presetGrid"></div>
    </div>

    <!-- 03 ã‚ªãƒ—ã‚·ãƒ§ãƒ³ -->
    <div class="card" id="secOpts" style="display:none">
      <div class="slabel">03 â€” ã‚µã‚¤ã‚º / å‡ºåŠ›è¨­å®š</div>

      <!-- å‹•ç”»ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ -->
      <div id="vfmtSec" style="display:none">
        <div class="ol" style="margin-bottom:8px;">å‹•ç”»å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ</div>
        <div class="vfmt">
          <button class="vb active" id="vbMp4" data-vf="mp4">MP4ï¼ˆH.264ï¼‰</button>
          <button class="vb" id="vbWebm" data-vf="webm">WebMï¼ˆVP9ï¼‰</button>
        </div>
        <div class="notice yellow show" id="mp4Warn" style="display:none">âš  ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯MP4ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰éå¯¾å¿œã§ã™ã€‚WebMã‚’ãŠä½¿ã„ãã ã•ã„ã€‚</div>
        <hr>
      </div>

      <!-- HEICå¤‰æ›å…ˆ -->
      <div id="heicFmtSec" style="display:none; margin-bottom:14px;">
        <div class="ol" style="margin-bottom:6px;">å¤‰æ›å…ˆãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ</div>
        <select id="heicFmt">
          <option value="image/jpeg">JPGï¼ˆæ¨å¥¨ï¼‰</option>
          <option value="image/png">PNG</option>
        </select>
        <hr style="margin-top:12px;">
      </div>

      <div class="opts">
        <div class="og">
          <div class="ol">ã‚«ã‚¹ã‚¿ãƒ ã‚µã‚¤ã‚ºï¼ˆpxï¼‰</div>
          <div class="cr">
            <input type="number" id="cw" placeholder="å¹…" min="1" max="7680">
            <span class="xl">Ã—</span>
            <input type="number" id="ch" placeholder="é«˜ã•" min="1" max="7680">
          </div>
        </div>
        <div class="og" id="imgFmtGrp">
          <div class="ol">å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ</div>
          <select id="fmt">
            <option value="image/png">PNG</option>
            <option value="image/jpeg">JPG</option>
            <option value="image/webp">WebP</option>
          </select>
        </div>
        <div class="og" id="qualGrp" style="display:none">
          <div class="ol">å“è³ª</div>
          <select id="qual">
            <option value="1">æœ€é«˜ (100%)</option>
            <option value="0.9" selected>é«˜ (90%)</option>
            <option value="0.75">ä¸­ (75%)</option>
            <option value="0.6">ä½ (60%)</option>
          </select>
        </div>
        <div class="og" id="trimGrp" style="display:none">
          <div class="ol">åˆ‡ã‚Šå‡ºã—æ™‚é–“ï¼ˆç§’ï¼‰</div>
          <div class="cr">
            <input type="number" id="targStart" placeholder="é–‹å§‹" min="0" step="0.1">
            <span class="xl">ã€œ</span>
            <input type="number" id="targEnd" placeholder="çµ‚äº†" min="0.1" step="0.1">
          </div>
        </div>
      </div>

      <div style="display:flex;gap:16px;flex-wrap:wrap;align-items:center;margin-top:10px;">
        <label class="chk"><input type="checkbox" id="ka" checked> ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ</label>
        <label class="chk"><input type="checkbox" id="fb" checked> ä½™ç™½ã‚’å¡—ã‚Šã¤ã¶ã—</label>
        <div style="display:flex;align-items:center;gap:6px;">
          <span style="font-family:var(--mono);font-size:12px;color:var(--muted);">èƒŒæ™¯è‰²</span>
          <input type="color" id="bgc" value="#ffffff">
        </div>
      </div>
    </div>

    <!-- 04 ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ & DL -->
    <div class="card" id="secPrev" style="display:none">
      <div class="slabel">04 â€” ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ & ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</div>
      <div class="prevgrid">
        <div class="pbox">
          <div class="pbox-lbl">å…ƒãƒ•ã‚¡ã‚¤ãƒ«</div>
          <canvas id="origC" style="display:none"></canvas>
          <video id="origV" controls muted style="display:none"></video>
          <div class="pinfo" id="origI"></div>
        </div>
        <div class="pbox">
          <div class="pbox-lbl">å¤‰æ›å¾Œ</div>
          <canvas id="resC" style="display:none"></canvas>
          <video id="resV" controls style="display:none"></video>
          <div class="pinfo" id="resI"></div>
        </div>
      </div>

      <!-- ç”»åƒç·¨é›†ã‚¨ãƒªã‚¢ -->
      <div class="editor-section" id="editorSection">
        <div class="editor-label">ç”»åƒã‚’èª¿æ•´ï¼ˆãƒã‚¦ã‚¹ã§æ“ä½œï¼‰</div>
        <div class="editor-toolbar">
          <span class="zoom-display" id="zoomDisplay">100%</span>
          <button class="btn-tool" id="zoomInBtn">ï¼‹ æ‹¡å¤§</button>
          <button class="btn-tool" id="zoomOutBtn">ï¼ ç¸®å°</button>
          <button class="btn-tool" id="fitBtn">ãƒ•ã‚£ãƒƒãƒˆ</button>
          <button class="btn-tool" id="editResetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
          <span style="font-family:var(--mono);font-size:11px;color:var(--muted);margin-left:6px;">ã‚¬ã‚¤ãƒ‰ç·š</span>
          <input type="color" id="rulerColor" value="#cccc00"
            style="width:28px;height:24px;border:1.5px solid var(--border);border-radius:3px;padding:1px;cursor:pointer;">
          <button class="btn-tool" id="rulerToggle">éè¡¨ç¤º</button>
        </div>
        <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;">
          <span class="editor-hint">ğŸ–± ãƒ›ã‚¤ãƒ¼ãƒ«: æ‹¡å¤§ç¸®å° / ãƒ‰ãƒ©ãƒƒã‚°: ä½ç½®ç§»å‹•</span>
        </div>
        <div class="editor-canvas-wrap" id="editorWrap">
          <canvas id="editCanvas"></canvas>
        </div>
      </div>

      <div class="sbar" id="sbar"></div>
      <div class="pgwrap" id="pgwrap">
        <div class="pglbl" id="pglbl">å‡¦ç†ä¸­...</div>
        <progress id="pgbar" value="0" max="100"></progress>
      </div>
      <div class="brow">
        <button class="btn-p" id="dlBtn" disabled>â¬‡ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        <button class="btn-s" id="resetBtn">ã‚„ã‚Šç›´ã™</button>
      </div>
    </div>

  </div>

  <script>
    'use strict';

    // ===== WebCodecs / mp4-muxer ãƒã‚§ãƒƒã‚¯ =====
    const hasWebCodecs = typeof VideoEncoder !== 'undefined';
    let mp4MuxerLib = null; // å¾Œã§å‹•çš„ãƒ­ãƒ¼ãƒ‰

    // mp4-muxerã‚’<script>ã‚¿ã‚°ã§å‹•çš„ãƒ­ãƒ¼ãƒ‰ã™ã‚‹
    async function loadMp4Muxer() {
      if (mp4MuxerLib) return mp4MuxerLib;
      if (typeof Mp4Muxer !== 'undefined') { mp4MuxerLib = Mp4Muxer; return Mp4Muxer; }
      const URLS = [
        'https://cdn.jsdelivr.net/npm/mp4-muxer/build/mp4-muxer.min.js',
        'https://unpkg.com/mp4-muxer/build/mp4-muxer.min.js',
      ];
      for (const url of URLS) {
        try {
          await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
          });
          if (typeof Mp4Muxer !== 'undefined') {
            mp4MuxerLib = Mp4Muxer;
            return Mp4Muxer;
          }
        } catch (e) { console.warn('mp4-muxer load failed:', url, e); }
      }
      return null;
    }

    // ===== ãƒ—ãƒªã‚»ãƒƒãƒˆ =====
    const PRESETS = [
      { pl: 'lineworks', name: 'ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç”»åƒ', w: 640, h: 640, vt: 'image', note: '3MBä»¥ä¸‹æ¨å¥¨' },
      { pl: 'lineworks', name: 'èƒŒæ™¯ãƒ»ã‚«ãƒãƒ¼ç”»åƒ', w: 1000, h: 635, vt: 'image' },
      { pl: 'line', name: 'ã‚¢ã‚¤ã‚³ãƒ³', w: 800, h: 800, vt: 'image' },
      { pl: 'line', name: 'èƒŒæ™¯', w: 720, h: 1280, vt: 'image' },
      { pl: 'booth', name: 'ã‚¢ã‚¤ã‚³ãƒ³', w: 600, h: 600, vt: 'image' },
      { pl: 'booth', name: 'ãƒãƒŠãƒ¼', w: 1500, h: 400, vt: 'image' },
      { pl: 'booth', name: 'å•†å“ç”»åƒ', w: 1200, h: 1200, vt: 'image' },
      { pl: 'note', name: 'ã‚¢ã‚¤ã‚³ãƒ³', w: 500, h: 500, vt: 'image' },
      { pl: 'note', name: 'ãƒ˜ãƒƒãƒ€ãƒ¼', w: 1280, h: 670, vt: 'image' },
      { pl: 'note', name: 'è¨˜äº‹ã‚µãƒ ãƒ', w: 1280, h: 670, vt: 'image' },
      { pl: 'youtube', name: 'ã‚µãƒ ãƒã‚¤ãƒ«', w: 1280, h: 720, vt: 'image' },
      { pl: 'youtube', name: 'ãƒãƒ£ãƒ³ãƒãƒ«ã‚¢ã‚¤ã‚³ãƒ³', w: 800, h: 800, vt: 'image' },
      { pl: 'youtube', name: 'ãƒãƒ£ãƒ³ãƒãƒ«ã‚¢ãƒ¼ãƒˆ', w: 2560, h: 1440, vt: 'image' },
      { pl: 'youtube', name: 'å‹•ç”»ï¼ˆæ¨ªï¼‰', w: 1920, h: 1080, vt: 'video', note: '16:9' },
      { pl: 'youtube', name: 'Shortsï¼ˆç¸¦ï¼‰', w: 1080, h: 1920, vt: 'video', note: '9:16' },
      { pl: 'tiktok', name: 'ç¸¦å‹•ç”»', w: 1080, h: 1920, vt: 'video', note: '9:16' },
      { pl: 'tiktok', name: 'ã‚¢ã‚¤ã‚³ãƒ³', w: 200, h: 200, vt: 'image' },
      { pl: 'twitter', name: 'ã‚¢ã‚¤ã‚³ãƒ³', w: 400, h: 400, vt: 'image' },
      { pl: 'twitter', name: 'ãƒ˜ãƒƒãƒ€ãƒ¼', w: 1500, h: 500, vt: 'image' },
      { pl: 'twitter', name: 'æŠ•ç¨¿ï¼ˆæ¨ªï¼‰', w: 1200, h: 675, vt: 'image' },
      { pl: 'twitter', name: 'æŠ•ç¨¿ï¼ˆæ­£æ–¹å½¢ï¼‰', w: 1080, h: 1080, vt: 'image' },
      { pl: 'instagram', name: 'æŠ•ç¨¿ï¼ˆæ­£æ–¹å½¢ï¼‰', w: 1080, h: 1080, vt: 'image' },
      { pl: 'instagram', name: 'ã‚¹ãƒˆãƒ¼ãƒªãƒ¼', w: 1080, h: 1920, vt: 'image' },
      { pl: 'instagram', name: 'æŠ•ç¨¿ï¼ˆæ¨ªï¼‰', w: 1080, h: 566, vt: 'image' },
      { pl: 'instagram', name: 'æŠ•ç¨¿ï¼ˆç¸¦ï¼‰', w: 1080, h: 1350, vt: 'image' },
      { pl: 'instagram', name: 'ãƒªãƒ¼ãƒ«', w: 1080, h: 1920, vt: 'video', note: '9:16' },
      { pl: 'facebook', name: 'ãƒ•ã‚£ãƒ¼ãƒ‰ï¼ˆæ­£æ–¹å½¢ï¼‰', w: 1080, h: 1080, vt: 'image' },
      { pl: 'facebook', name: 'ãƒ•ã‚£ãƒ¼ãƒ‰ï¼ˆç¸¦é•·ï¼‰', w: 1080, h: 1350, vt: 'image' },
      { pl: 'facebook', name: 'ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã‚º/ãƒªãƒ¼ãƒ«', w: 1080, h: 1920, vt: 'video', note: '9:16' },
      { pl: 'pinterest', name: 'ãƒ”ãƒ³ï¼ˆæ¨™æº–ï¼‰', w: 1000, h: 1500, vt: 'image', note: '2:3' },
      { pl: 'pinterest', name: 'ã‚¢ã‚¤ã‚³ãƒ³', w: 165, h: 165, vt: 'image' },
    ];
    const PLABELS = { lineworks: 'LINE WORKS', line: 'LINE', booth: 'BOOTH', note: 'note', youtube: 'YouTube', tiktok: 'TikTok', twitter: 'Twitter/X', instagram: 'Instagram', facebook: 'Facebook', pinterest: 'Pinterest' };

    // ===== çŠ¶æ…‹ =====
    let fileType = null, isHeic = false, currentFile = null;
    let origImg = null, dlBlob = null, lastDlUrl = null;
    let targetW = 0, targetH = 0;
    let videoFmt = 'mp4';

    // ç”»åƒç·¨é›†çŠ¶æ…‹
    let editScale = 1, editOffX = 0, editOffY = 0;
    let isDragging = false, dragStartX = 0, dragStartY = 0, dragOffX = 0, dragOffY = 0;

    // ===== DOM =====
    const G = id => document.getElementById(id);
    const fi = G('fi'), dz = G('dz');
    const origC = G('origC'), origV = G('origV');
    const resC = G('resC'), resV = G('resV');
    const origI = G('origI'), resI = G('resI');
    const cw = G('cw'), ch = G('ch');
    const fmtSel = G('fmt'), qualSel = G('qual');
    const targStart = G('targStart'), targEnd = G('targEnd');
    const ka = G('ka'), fb = G('fb'), bgc = G('bgc');
    const dlBtn = G('dlBtn'), resetBtn = G('resetBtn');
    const sbar = G('sbar'), pgwrap = G('pgwrap'), pgbar = G('pgbar'), pglbl = G('pglbl');
    const heicFmt = G('heicFmt');

    // WebCodecséå¯¾å¿œãªã‚‰ MP4 ãƒœã‚¿ãƒ³ç„¡åŠ¹
    if (!hasWebCodecs) {
      G('vbMp4').disabled = true;
      videoFmt = 'webm';
      G('vbWebm').classList.add('active');
      G('vbMp4').classList.remove('active');
      G('mp4Warn').style.display = 'block';
    }

    // ===== ã‚¤ãƒ™ãƒ³ãƒˆ =====
    dz.addEventListener('dragover', e => { e.preventDefault(); dz.classList.add('over'); });
    dz.addEventListener('dragleave', () => dz.classList.remove('over'));
    dz.addEventListener('drop', e => { e.preventDefault(); dz.classList.remove('over'); if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]); });
    fi.addEventListener('change', e => { if (e.target.files[0]) handleFile(e.target.files[0]); });

    fmtSel.addEventListener('change', () => {
      G('qualGrp').style.display = ['image/jpeg', 'image/webp'].includes(fmtSel.value) ? 'block' : 'none';
      updatePreview();
    });
    [cw, ch, ka, fb, bgc, qualSel, heicFmt].forEach(el => el && el.addEventListener('change', updatePreview));
    [targStart, targEnd].forEach(el => el && el.addEventListener('input', () => {
      if (fileType === 'video') updatePreview();
    }));

    document.querySelectorAll('.vb').forEach(b => b.addEventListener('click', () => {
      if (b.disabled) return;
      document.querySelectorAll('.vb').forEach(x => x.classList.remove('active'));
      b.classList.add('active');
      videoFmt = b.dataset.vf;
      updatePreview();
    }));

    G('platTabs').addEventListener('click', e => {
      const btn = e.target.closest('.tab');
      if (!btn) return;
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      btn.classList.add('active');
      renderPresets(btn.dataset.p);
    });

    // ===== ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç† =====
    async function handleFile(f) {
      currentFile = f;
      const nm = f.name.toLowerCase();
      isHeic = nm.endsWith('.heic') || nm.endsWith('.heif') || f.type === 'image/heic' || f.type === 'image/heif';
      const isVid = f.type.startsWith('video/') || nm.endsWith('.mov') || nm.endsWith('.mp4') || nm.endsWith('.webm');
      fileType = isVid ? 'video' : 'image';

      G('secPreset').style.display = 'block';
      G('secOpts').style.display = 'block';
      G('secPrev').style.display = 'block';
      dlBtn.disabled = true; dlBtn.textContent = 'â¬‡ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰'; dlBlob = null;

      G('heicNotice').className = 'notice orange' + (isHeic ? ' show' : '');
      G('heicFmtSec').style.display = isHeic ? 'block' : 'none';
      G('vfmtSec').style.display = fileType === 'video' ? 'block' : 'none';
      G('imgFmtGrp').style.display = (fileType === 'image' && !isHeic) ? 'block' : 'none';
      G('trimGrp').style.display = fileType === 'video' ? 'block' : 'none';
      G('errNotice').className = 'notice red';

      if (fileType === 'image') {
        await loadImg(f);
      } else {
        await loadVid(f);
      }
      renderPresets('all');
      updatePreview();
    }

    // ===== ç”»åƒèª­ã¿è¾¼ã¿ï¼ˆHEIC ã¯ãƒ–ãƒ©ã‚¦ã‚¶ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ‡ã‚³ãƒ¼ãƒ‰ï¼‰=====
    async function loadImg(f) {
      showStatus('èª­ã¿è¾¼ã¿ä¸­...', 'proc');
      const url = URL.createObjectURL(f);
      origImg = new Image();

      try {
        await new Promise((resolve, reject) => {
          origImg.onload = resolve;
          origImg.onerror = reject;
          origImg.src = url;
        });
      } catch (e) {
        // HEIC ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ãŒç›´æ¥ãƒ‡ã‚³ãƒ¼ãƒ‰ã§ããªã„å ´åˆ
        if (isHeic) {
          showErr('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯HEICã‚’ãƒã‚¤ãƒ†ã‚£ãƒ–å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚\nChromeã¾ãŸã¯Safariã®æœ€æ–°ç‰ˆã‚’ã”ä½¿ç”¨ãã ã•ã„ã€‚\nï¼ˆChrome 105+ / Safari ã¯å¯¾å¿œæ¸ˆã¿ï¼‰');
        } else {
          showErr('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
        }
        URL.revokeObjectURL(url);
        return;
      }

      origC.style.display = 'block'; origV.style.display = 'none';
      const ctx = origC.getContext('2d');
      origC.width = origImg.naturalWidth; origC.height = origImg.naturalHeight;
      ctx.drawImage(origImg, 0, 0);
      origI.textContent = `${origImg.naturalWidth} Ã— ${origImg.naturalHeight} px\n${fmtSize(f.size)}`;

      if (!isHeic) {
        fmtSel.value = f.type === 'image/jpeg' ? 'image/jpeg' : f.type === 'image/webp' ? 'image/webp' : 'image/png';
      }
      showStatus('', '');
    }

    async function loadVid(f) {
      const url = URL.createObjectURL(f);
      origV.src = url; origV.style.display = 'block'; origC.style.display = 'none';
      await new Promise(r => { origV.onloadedmetadata = r; });
      origI.textContent = `${origV.videoWidth} Ã— ${origV.videoHeight} px\n${fmtSize(f.size)} / ${fmtDur(origV.duration)}`;
      targStart.value = 0;
      targEnd.value = origV.duration;
    }

    // ===== ãƒ—ãƒªã‚»ãƒƒãƒˆ =====
    function renderPresets(platform) {
      const list = platform === 'all' ? PRESETS : PRESETS.filter(p => p.pl === platform);
      const grid = G('presetGrid'); grid.innerHTML = '';
      list.forEach(p => {
        if (fileType === 'video' && p.vt === 'image') return;
        if (fileType === 'image' && p.vt === 'video') return;
        const d = document.createElement('div');
        d.className = 'pc' + (p.vt === 'video' ? ' vid' : '');
        d.innerHTML = `<div class="pp">${PLABELS[p.pl]}</div><div class="pn">${p.name}</div><div class="ps">${p.w} Ã— ${p.h}</div><span class="pb ${p.vt === 'video' ? 'v' : ''}">${p.note || p.vt}</span>`;
        d.addEventListener('click', () => {
          document.querySelectorAll('.pc').forEach(c => c.classList.remove('sel'));
          d.classList.add('sel');
          cw.value = p.w; ch.value = p.h;
          updatePreview();
        });
        grid.appendChild(d);
      });
    }

    // ===== ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–° =====
    function updatePreview() {
      if (!currentFile || !origImg && fileType === 'image') return;
      const w = parseInt(cw.value) || (origImg ? origImg.naturalWidth : 0);
      const h = parseInt(ch.value) || (origImg ? origImg.naturalHeight : 0);
      if (!w || !h) return;
      targetW = w; targetH = h;

      if (fileType === 'image') {
        drawResized(w, h);
      } else {
        resV.src = origV.src; resV.style.display = 'block'; resC.style.display = 'none';
        const start = parseFloat(targStart.value) || 0;
        const end = parseFloat(targEnd.value) || origV.duration;
        const duration = end - start;
        resI.textContent = `å¤‰æ›å¾Œ: ${w} Ã— ${h} px\nå‡ºåŠ›: ${videoFmt.toUpperCase()}\nãƒˆãƒªãƒ : ${fmtDur(start)} ã€œ ${fmtDur(end)} (${fmtDur(duration)})\nâ–¶ã€Œå¤‰æ›ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„`;
        dlBtn.disabled = false;
        dlBtn.textContent = 'â¬‡ å¤‰æ›ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰';
        dlBtn.onclick = () => videoFmt === 'mp4' ? doMP4(w, h, start, end) : doWebM(w, h, start, end);
      }
    }

    // ===== ç”»åƒãƒªã‚µã‚¤ã‚º =====
    function drawResized(w, h) {
      resC.style.display = 'block'; resV.style.display = 'none';
      resC.width = w; resC.height = h;
      const ctx = resC.getContext('2d');
      if (fb.checked) { ctx.fillStyle = bgc.value; ctx.fillRect(0, 0, w, h); }
      else ctx.clearRect(0, 0, w, h);

      if (ka.checked) {
        const iw = origImg.naturalWidth, ih = origImg.naturalHeight;
        const s = Math.min(w / iw, h / ih);
        ctx.drawImage(origImg, (w - iw * s) / 2, (h - ih * s) / 2, iw * s, ih * s);
      } else {
        ctx.drawImage(origImg, 0, 0, w, h);
      }

      // ç·¨é›†ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚’åˆæœŸåŒ–ã—ã¦è¡¨ç¤º
      editScale = 1; editOffX = 0; editOffY = 0;
      G('editorSection').classList.add('show');
      drawEditCanvas();

      resI.textContent = `å¤‰æ›å¾Œ: ${w} Ã— ${h} px\nç”»åƒã‚’èª¿æ•´ã—ã¦ã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™`;
      dlBtn.disabled = false;
      dlBtn.textContent = 'â¬‡ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰';
      dlBtn.onclick = dlImg;
      showStatus('', '');
    }

    // ===== ç·¨é›†ã‚­ãƒ£ãƒ³ãƒã‚¹æç”» =====
    function drawEditCanvas() {
      const ec = G('editCanvas');
      const w = targetW, h = targetH;
      ec.width = w; ec.height = h;
      const ctx = ec.getContext('2d');

      // èƒŒæ™¯
      if (fb.checked) { ctx.fillStyle = bgc.value; ctx.fillRect(0, 0, w, h); }
      else ctx.clearRect(0, 0, w, h);

      // ç”»åƒã‚’æ‹¡å¤§ç‡ãƒ»ã‚ªãƒ•ã‚»ãƒƒãƒˆä»˜ãã§æç”»
      const iw = origImg.naturalWidth, ih = origImg.naturalHeight;
      let dw, dh, dx, dy;
      if (ka.checked) {
        const s = Math.min(w / iw, h / ih) * editScale;
        dw = iw * s; dh = ih * s;
        dx = (w - dw) / 2 + editOffX;
        dy = (h - dh) / 2 + editOffY;
      } else {
        dw = w * editScale; dh = h * editScale;
        dx = (w - dw) / 2 + editOffX;
        dy = (h - dh) / 2 + editOffY;
      }
      ctx.drawImage(origImg, dx, dy, dw, dh);

      // ãƒ«ãƒ¼ãƒ©ãƒ¼ã‚’æç”»ï¼ˆè–„ã„ç›®ç››ã‚Šç·šï¼‰
      drawRuler(ctx, w, h);

      // ã‚ºãƒ¼ãƒ è¡¨ç¤ºæ›´æ–°
      G('zoomDisplay').textContent = `${Math.round(editScale * 100)}%`;
    }

    let rulerVisible = true;

    function drawRuler(ctx, w, h) {
      if (!rulerVisible) return;
      ctx.save();

      const color = G('rulerColor').value;
      // hex â†’ rgba (é€éåº¦0.35)
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      const lineColor = `rgba(${r},${g},${b},0.35)`;
      const textColor = `rgba(${r},${g},${b},0.6)`;

      const step = 50;
      const major = 100;

      // ã‚°ãƒªãƒƒãƒ‰ç·šï¼ˆç”»åƒå…¨ä½“ã«è¢«ã›ã‚‹ï¼‰
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 0.5;
      for (let x = step; x < w; x += step) {
        ctx.lineWidth = (x % major === 0) ? 0.8 : 0.4;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
      for (let y = step; y < h; y += step) {
        ctx.lineWidth = (y % major === 0) ? 0.8 : 0.4;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }

      // ãƒ©ãƒ™ãƒ«ï¼ˆ100pxæ¯ï¼‰
      ctx.fillStyle = textColor;
      ctx.font = '9px monospace';
      ctx.textBaseline = 'top';
      ctx.textAlign = 'left';
      for (let x = major; x < w; x += major) {
        ctx.fillText(x, x + 2, 2);
      }
      for (let y = major; y < h; y += major) {
        ctx.fillText(y, 2, y + 2);
      }

      ctx.restore();
    }

    // ===== ç·¨é›†ã‚­ãƒ£ãƒ³ãƒã‚¹æ“ä½œ =====
    (function setupEditor() {
      const ec = G('editCanvas');
      const wrap = G('editorWrap');

      // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«: æ‹¡å¤§ãƒ»ç¸®å°
      wrap.addEventListener('wheel', e => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        editScale = Math.max(0.1, Math.min(10, editScale + delta));
        drawEditCanvas();
      }, { passive: false });

      // ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°: ä½ç½®ç§»å‹•
      ec.addEventListener('mousedown', e => {
        isDragging = true;
        ec.classList.add('dragging');
        dragStartX = e.clientX; dragStartY = e.clientY;
        dragOffX = editOffX; dragOffY = editOffY;
        e.preventDefault();
      });
      document.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const rect = ec.getBoundingClientRect();
        const scaleRatio = ec.width / rect.width;
        editOffX = dragOffX + (e.clientX - dragStartX) * scaleRatio;
        editOffY = dragOffY + (e.clientY - dragStartY) * scaleRatio;
        drawEditCanvas();
      });
      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          G('editCanvas').classList.remove('dragging');
        }
      });

      // ã‚¿ãƒƒãƒå¯¾å¿œ
      ec.addEventListener('touchstart', e => {
        if (e.touches.length === 1) {
          isDragging = true;
          const t = e.touches[0];
          dragStartX = t.clientX; dragStartY = t.clientY;
          dragOffX = editOffX; dragOffY = editOffY;
          e.preventDefault();
        }
      }, { passive: false });
      document.addEventListener('touchmove', e => {
        if (!isDragging || e.touches.length !== 1) return;
        const t = e.touches[0];
        const rect = ec.getBoundingClientRect();
        const scaleRatio = ec.width / rect.width;
        editOffX = dragOffX + (t.clientX - dragStartX) * scaleRatio;
        editOffY = dragOffY + (t.clientY - dragStartY) * scaleRatio;
        drawEditCanvas();
      }, { passive: false });
      document.addEventListener('touchend', () => {
        isDragging = false;
      });

      // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ãƒœã‚¿ãƒ³
      G('zoomInBtn').addEventListener('click', () => {
        editScale = Math.min(10, editScale + 0.2);
        drawEditCanvas();
      });
      G('zoomOutBtn').addEventListener('click', () => {
        editScale = Math.max(0.1, editScale - 0.2);
        drawEditCanvas();
      });
      G('fitBtn').addEventListener('click', () => {
        editScale = 1; editOffX = 0; editOffY = 0;
        drawEditCanvas();
      });
      G('editResetBtn').addEventListener('click', () => {
        editScale = 1; editOffX = 0; editOffY = 0;
        drawEditCanvas();
      });
      G('rulerColor').addEventListener('input', () => {
        drawEditCanvas();
      });
      G('rulerToggle').addEventListener('click', () => {
        rulerVisible = !rulerVisible;
        G('rulerToggle').textContent = rulerVisible ? 'éè¡¨ç¤º' : 'è¡¨ç¤º';
        drawEditCanvas();
      });
    })();

    function dlImg() {
      // ãƒ«ãƒ¼ãƒ©ãƒ¼ãªã—ã®æœ€çµ‚ç”»åƒã‚’ç”Ÿæˆã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
      const w = targetW, h = targetH;
      const off = mkCanvas(w, h);
      const ctx = off.getContext('2d');

      if (fb.checked) { ctx.fillStyle = bgc.value; ctx.fillRect(0, 0, w, h); }
      else ctx.clearRect(0, 0, w, h);

      const iw = origImg.naturalWidth, ih = origImg.naturalHeight;
      let dw, dh, dx, dy;
      if (ka.checked) {
        const s = Math.min(w / iw, h / ih) * editScale;
        dw = iw * s; dh = ih * s;
        dx = (w - dw) / 2 + editOffX;
        dy = (h - dh) / 2 + editOffY;
      } else {
        dw = w * editScale; dh = h * editScale;
        dx = (w - dw) / 2 + editOffX;
        dy = (h - dh) / 2 + editOffY;
      }
      ctx.drawImage(origImg, dx, dy, dw, dh);

      const f = isHeic ? heicFmt.value : fmtSel.value;
      const q = parseFloat(qualSel.value);
      off.toBlob(blob => {
        if (!blob) return;
        const ext = f.split('/')[1].replace('jpeg', 'jpg');
        triggerDL(URL.createObjectURL(blob), `resized_${targetW}x${targetH}.${ext}`);
        resI.textContent = `å¤‰æ›å¾Œ: ${targetW} Ã— ${targetH} px\n${fmtSize(blob.size)}`;
        showStatus(`âœ“ resized_${targetW}x${targetH}.${ext} ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ`, 'done');
      }, f, q);
    }

    // ===== å‹•ç”» WebM =====
    async function doWebM(w, h, start, end) {
      dlBtn.disabled = true;
      showStatus('WebM ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­...', 'proc'); startProg();
      const video = origV;
      await seekWait(video, start); // currentTimeã®è¨­å®šã‚’seekWaitå†…ã«éš è”½ã—ã€å®‰å…¨ã«å¾…ã¤
      const off = mkCanvas(w, h), ctx = off.getContext('2d');
      const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : 'video/webm';
      const rec = new MediaRecorder(off.captureStream(30), { mimeType: mime, videoBitsPerSecond: 8e6 });
      const chunks = [];
      rec.ondataavailable = e => e.data.size && chunks.push(e.data);
      rec.start();
      video.muted = true; video.play();
      const dur = end - start;
      function draw() {
        if (video.currentTime >= end || video.ended || video.paused) { rec.stop(); return; }
        drawF(ctx, video, w, h);
        setProg((video.currentTime - start) / dur, `${~~(video.currentTime - start)}s / ${~~dur}s`);
        requestAnimationFrame(draw);
      }
      video.onended = () => rec.stop();
      draw();
      rec.onstop = () => finishVid(new Blob(chunks, { type: 'video/webm' }), w, h, 'webm');
    }

    // ===== å‹•ç”» MP4 (WebCodecs + mp4-muxer) =====
    async function doMP4(w, h, start, end) {
      // H.264 ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ã¯å¹…ã¨é«˜ã•ãŒå¶æ•°ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚åˆ‡ã‚Šæ¨ã¦
      w = Math.floor(w / 2) * 2;
      h = Math.floor(h / 2) * 2;

      if (!hasWebCodecs) { showErr('MP4ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰éå¯¾å¿œã€‚WebMã‚’ãŠä½¿ã„ãã ã•ã„ã€‚'); dlBtn.disabled = false; return; }

      dlBtn.disabled = true;
      showStatus('mp4-muxer / éŸ³å£°è§£æ æº–å‚™ä¸­...', 'proc');

      const lib = await loadMp4Muxer();
      if (!lib) {
        showErr('mp4-muxer ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚WebMã‚’ãŠè©¦ã—ãã ã•ã„ã€‚');
        dlBtn.disabled = false; return;
      }

      showStatus('MP4 ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­... éŸ³å£°ãŒã‚ã‚‹å ´åˆã¯è§£æã«æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™', 'proc'); startProg();

      const video = origV, fps = 30;
      const duration = end - start;
      const totalFrames = Math.ceil(duration * fps);

      // --- éŸ³å£°ãƒˆãƒ©ãƒƒã‚¯ã®æŠ½å‡º ---
      let audioBuffer = null;
      let hasAudio = false;
      try {
        const audioRes = await fetch(video.src);
        const arrayBuf = await audioRes.arrayBuffer();
        const actx = new (window.AudioContext || window.webkitAudioContext)();
        audioBuffer = await actx.decodeAudioData(arrayBuf);
        hasAudio = true;
      } catch (e) {
        console.warn('Audio decoding failed or no audio:', e);
      }

      // ã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã‚µãƒãƒ¼ãƒˆç¢ºèªï¼ˆè§£åƒåº¦ã«åˆã‚ã›ã¦é©åˆ‡ãªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ç´¢ï¼‰
      const codecs = [
        'avc1.42E02A', // Constrained Baseline Profile, Level 4.2 (up to 1080p60)
        'avc1.4D002A', // Main Profile, Level 4.2
        'avc1.640028', // High Profile, Level 4.0
        'avc1.42001f', // Baseline Profile, Level 3.1 (up to 720p30)
      ];
      let targetCodec = null;
      for (const c of codecs) {
        try {
          const r = await VideoEncoder.isConfigSupported({ codec: c, width: w, height: h, bitrate: 8e6, framerate: fps });
          if (r.supported) { targetCodec = c; break; }
        } catch (e) { }
      }
      if (!targetCodec) { showErr('æŒ‡å®šã‚µã‚¤ã‚ºã§ã®H.264ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰éå¯¾å¿œã€‚WebMã‚’ãŠè©¦ã—ãã ã•ã„ã€‚'); dlBtn.disabled = false; return; }

      let muxer, encoder, audioEncoder;
      try {
        const muxerOpts = {
          target: new lib.ArrayBufferTarget(),
          video: { codec: 'avc', width: w, height: h },
          fastStart: 'in-memory',
        };
        if (hasAudio) {
          muxerOpts.audio = {
            codec: 'aac',
            sampleRate: audioBuffer.sampleRate,
            numberOfChannels: audioBuffer.numberOfChannels
          };
        }
        muxer = new lib.Muxer(muxerOpts);
        encoder = new VideoEncoder({
          output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
          error: e => showErr('ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ' + e.message),
        });
        encoder.configure({ codec: targetCodec, width: w, height: h, bitrate: 8e6, framerate: fps });

        if (hasAudio) {
          audioEncoder = new AudioEncoder({
            output: (chunk, meta) => muxer.addAudioChunk(chunk, meta),
            error: e => console.warn('AudioEncoder error:', e)
          });
          audioEncoder.configure({
            codec: 'mp4a.40.2',
            sampleRate: audioBuffer.sampleRate,
            numberOfChannels: audioBuffer.numberOfChannels,
            bitrate: 128000
          });
        }
      } catch (e) {
        showErr('MP4åˆæœŸåŒ–å¤±æ•—: ' + e.message); dlBtn.disabled = false; return;
      }

      const off = mkCanvas(w, h), ctx = off.getContext('2d');
      video.muted = true;

      // éŸ³å£°ãƒ‡ãƒ¼ã‚¿åˆ†å‰²ç”¨ã®è¨­å®š
      const audioSampleRate = hasAudio ? audioBuffer.sampleRate : 0;
      let lastAudioTime = start;
      for (let i = 0; i < totalFrames; i++) {
        const t = start + (i / fps);
        if (t >= end) break;
        await seekWait(video, t);
        drawF(ctx, video, w, h);
        const frame = new VideoFrame(off, { timestamp: Math.round((t - start) * 1e6) });
        encoder.encode(frame, { keyFrame: i % (fps * 2) === 0 });
        frame.close();

        // æ˜ åƒãƒ•ãƒ¬ãƒ¼ãƒ ã«åŒæœŸã—ã¦éŸ³å£°ã‚’åˆ‡ã‚Šå‡ºã—ã¦ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
        if (hasAudio) {
          const nextAudioTime = Math.min(t, audioBuffer.duration);
          if (nextAudioTime > lastAudioTime) {
            const startIdx = Math.floor(lastAudioTime * audioSampleRate);
            const endIdx = Math.floor(nextAudioTime * audioSampleRate);
            const frames = endIdx - startIdx;
            if (frames > 0) {
              const audioData = new AudioData({
                format: 'f32-planar',
                sampleRate: audioSampleRate,
                numberOfFrames: frames,
                numberOfChannels: audioBuffer.numberOfChannels,
                timestamp: Math.round((lastAudioTime - start) * 1e6),
                data: (() => {
                  const arr = new Float32Array(frames * audioBuffer.numberOfChannels);
                  for (let c = 0; c < audioBuffer.numberOfChannels; c++) {
                    const channelData = audioBuffer.getChannelData(c);
                    arr.set(channelData.subarray(startIdx, endIdx), c * frames);
                  }
                  return arr;
                })()
              });
              audioEncoder.encode(audioData);
              audioData.close();
            }
            lastAudioTime = nextAudioTime;
          }
        }

        setProg(i / totalFrames, `ãƒ•ãƒ¬ãƒ¼ãƒ  ${i}/${totalFrames} (${~~(i / totalFrames * 100)}%)`);
        if (i % 15 === 0) await tick();
      }

      // çµ‚äº†æ™‚é–“ã‚’è¶…ãˆãŸåˆ†ã®ä½™ã‚Šã®éŸ³å£°ã‚’ãƒ—ãƒƒã‚·ãƒ¥
      if (hasAudio && lastAudioTime < Math.min(end, audioBuffer.duration)) {
        const nextAudioTime = Math.min(end, audioBuffer.duration);
        const startIdx = Math.floor(lastAudioTime * audioSampleRate);
        const endIdx = Math.floor(nextAudioTime * audioSampleRate);
        const frames = endIdx - startIdx;
        if (frames > 0) {
          const audioData = new AudioData({
            format: 'f32-planar',
            sampleRate: audioSampleRate,
            numberOfFrames: frames,
            numberOfChannels: audioBuffer.numberOfChannels,
            timestamp: Math.round((lastAudioTime - start) * 1e6),
            data: (() => {
              const arr = new Float32Array(frames * audioBuffer.numberOfChannels);
              for (let c = 0; c < audioBuffer.numberOfChannels; c++) {
                const channelData = audioBuffer.getChannelData(c);
                arr.set(channelData.subarray(startIdx, endIdx), c * frames);
              }
              return arr;
            })()
          });
          audioEncoder.encode(audioData);
          audioData.close();
        }
      }

      await encoder.flush();
      if (hasAudio) await audioEncoder.flush();
      muxer.finalize();
      finishVid(new Blob([muxer.target.buffer], { type: 'video/mp4' }), w, h, 'mp4');
    }

    function finishVid(blob, w, h, ext) {
      setProg(1, 'å®Œäº†');
      if (lastDlUrl) URL.revokeObjectURL(lastDlUrl);
      lastDlUrl = URL.createObjectURL(blob);
      resV.src = lastDlUrl; resV.style.display = 'block'; resC.style.display = 'none';
      resI.textContent = `å¤‰æ›å¾Œ: ${w} Ã— ${h} px\n${fmtSize(blob.size)}`;
      const fname = `resized_${w}x${h}.${ext}`;
      triggerDL(lastDlUrl, fname);
      dlBtn.disabled = false; dlBtn.textContent = 'â¬‡ å†ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰';
      dlBtn.onclick = () => triggerDL(lastDlUrl, fname);
      showStatus(`âœ“ ${fname} ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ`, 'done');
      pgwrap.classList.remove('show');
    }

    // ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
    function drawF(ctx, video, w, h) {
      ctx.fillStyle = bgc.value; ctx.fillRect(0, 0, w, h);
      if (ka.checked) {
        const vw = video.videoWidth, vh = video.videoHeight, s = Math.min(w / vw, h / vh);
        ctx.drawImage(video, (w - vw * s) / 2, (h - vh * s) / 2, vw * s, vh * s);
      } else { ctx.drawImage(video, 0, 0, w, h); }
    }
    function mkCanvas(w, h) { const c = document.createElement('canvas'); c.width = w; c.height = h; return c; }
    function seekWait(v, t) {
      return new Promise(r => {
        if (Math.abs(v.currentTime - t) < 0.01) return r();
        const handle = () => { v.removeEventListener('seeked', handle); r(); };
        v.addEventListener('seeked', handle, { once: true });
        v.currentTime = t;
      });
    }
    function tick() { return new Promise(r => setTimeout(r, 0)); }
    function triggerDL(url, name) { const a = document.createElement('a'); a.href = url; a.download = name; a.click(); }
    function fmtSize(b) { return b >= 1048576 ? (b / 1048576).toFixed(1) + ' MB' : (b / 1024).toFixed(0) + ' KB'; }
    function fmtDur(s) { return `${~~(s / 60)}:${String(~~(s % 60)).padStart(2, '0')}`; }
    function showStatus(msg, type) {
      sbar.textContent = msg;
      sbar.className = 'sbar' + (msg ? ' show' : '') + (type ? ' ' + type : '');
    }
    function showErr(msg) {
      const n = G('errNotice'); n.textContent = 'âš  ' + msg; n.className = 'notice red show';
      showStatus(msg.split('\n')[0], 'err');
    }
    function startProg() { pgwrap.classList.add('show'); pgbar.value = 0; }
    function setProg(r, label) { pgbar.value = Math.round(r * 100); pglbl.textContent = label; }

    // ===== ãƒªã‚»ãƒƒãƒˆ =====
    resetBtn.addEventListener('click', () => {
      currentFile = null; fileType = null; isHeic = false; origImg = null; dlBlob = null; fi.value = '';
      origV.src = ''; origV.style.display = 'none'; origC.style.display = 'none';
      resV.src = ''; resV.style.display = 'none'; resC.style.display = 'none';
      G('secPreset').style.display = 'none'; G('secOpts').style.display = 'none'; G('secPrev').style.display = 'none';
      G('editorSection').classList.remove('show');
      editScale = 1; editOffX = 0; editOffY = 0;
      cw.value = ''; ch.value = ''; targStart.value = ''; targEnd.value = '';
      G('heicNotice').className = 'notice orange'; G('errNotice').className = 'notice red';
      dlBtn.disabled = true; dlBtn.textContent = 'â¬‡ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰';
      showStatus('', ''); pgwrap.classList.remove('show');
    });

    // ===== ãƒšãƒ¼ã‚¸é›¢è„±é˜²æ­¢ =====
    window.addEventListener('beforeunload', (e) => {
      if (pgwrap.classList.contains('show')) {
        e.preventDefault();
        e.returnValue = '';
      }
    });
  </script>
</body>

</html>